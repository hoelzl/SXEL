#lang poem

(require redex)
(provide sxel proc)

(define-language sxel
  ;; Processes
  (P Q ::= nil (pre a P) (+ P_1 P_2) (comp P_1 P_2) X (A any ...))
  ;; Names for processes
  (A   ::= (variable-prefix A))
  ;; Actions
  (a   ::= (get T c) (qry T c) (put t c) (fresh n) (new I K Π P))
  ;; Targets (references to knowledge repositories)
  (c   ::= n x self P (ref I variable))
  ;; Templates
  (T   ::= (any any ...))
  ;; Tuples
  (t   ::= (any any ...))
  ;; Interface names
  (I   ::= (variable-prefix I) (variable-prefix J))
  ;; Knowledge repositories
  (K   ::= (any ...))
  ;; Policies
  (Π   ::= (variable-prefix Π))
  ;; Names
  (n   ::= (variable-prefix n))
  ;; Process variables
  (X   ::= (variable-prefix X) (variable-prefix Y) (variable-prefix Z))
  ;; Variables for names
  (x   ::= (variable-prefix x) (variable-prefix y) (variable-prefix z))

  ;; Commitments (not terms, but used by the semantics)
  (α β ::= a ○ (comp α β)))


(define-judgment-form sxel
  #:mode (proc I O O)
  #:contract (proc P P α)
  ((proc (pre a P) P a)    prefix)

  ((proc P P ○)    no-op)

  ((proc P_1 P_2 α)
   -----------------------    +-left
   (proc (+ P_1 Q) P_2 α))

  ((proc Q_1 Q_2 α)
   -----------------------   --left
   (proc (+ P Q_1) Q_2 α))

  ;; Substitution is still missing, therefore no A(...)

  ((proc P_1 P_2 α) (proc Q_1 Q_2 β)
   ----------------------------------------------   comp
   (proc (comp P_1 Q_1) (comp P_2 Q_2) (comp α β))))
